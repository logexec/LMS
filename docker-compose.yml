services:

  # backend:
  #   build:
  #     context: ./backend
  #     dockerfile: Dockerfile
  #   container_name: backend
  #   image: lms-backend:latest
  #   env_file:
  #     - ./backend/.env.docker
  #   ports:
  #     - "8000:80"
  #   volumes:
  #     - ./wireguard-client/wg0.conf:/etc/wireguard/wg0.conf:ro
  #   cap_add:
  #     - NET_ADMIN
  #   devices:
  #     - /dev/net/tun
  #   depends_on:
  #     db:
  #       condition: service_healthy


  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: backend
    image: lms-backend:latest
    env_file:
      - ./backend/.env.docker
    volumes:
      # Código en readonly
      - ./backend:/var/www/html:ro
      # Sólo estos dirs en rw para logs y cache
      - ./backend/storage/logs:/var/www/html/storage/logs:rw
      - ./backend/storage/framework:/var/www/html/storage/framework:rw
      - ./backend/bootstrap/cache:/var/www/html/bootstrap/cache:rw
      - ./wireguard-client/wg0.conf:/etc/wireguard/wg0.conf:ro
    cap_add:
      - NET_ADMIN
    devices:
      - /dev/net/tun
    expose:
      - "9000"
    depends_on:
      db:
        condition: service_healthy

  nginx:
    image: nginx:1.25-alpine
    ports:
      - "8000:80"
    volumes:
      - ./backend:/var/www/html:ro
      - ./backend/docker/nginx/nginx.conf:/etc/nginx/conf.d/default.conf:ro
    depends_on:
      - backend

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    container_name: frontend
    image: lms-frontend:latest
    env_file:
      - ./frontend/.env   # el env de producción
    ports:
      - "3000:3000"
    depends_on:
      - backend
    # command: ["npm", "run", "dev"]

  db:
    image: mysql:8.0
    container_name: db
    restart: unless-stopped
    environment:
      MYSQL_ROOT_PASSWORD: root123!
      MYSQL_DATABASE: lms_backend
      MYSQL_USER: restrella
      MYSQL_PASSWORD: "LogeX-?2028*"
    volumes:
      - db_data:/var/lib/mysql
    healthcheck:
      test: [ "CMD", "mysqladmin", "ping", "-h", "localhost", "-uroot", "-proot123!" ]
      interval: 10s
      timeout: 5s
      retries: 5

  queue-worker:
    image: lms-backend:latest
    container_name: queue-worker
    restart: unless-stopped
    env_file:
      - ./backend/.env.docker
    volumes:
      - ./backend:/var/www/html
      - ./wireguard-client/wg0.conf:/etc/wireguard/wg0.conf:ro
    cap_add:
      - NET_ADMIN
    devices:
      - /dev/net/tun
    depends_on:
      - backend
    working_dir: /var/www/html
    entrypoint: >
      sh -c "wg-quick up wg0 && php artisan queue:work --sleep=3 --tries=3"
    # deploy:
    #   replicas: 5

  scheduler:
    image: lms-backend:latest
    container_name: scheduler
    restart: unless-stopped
    env_file:
      - ./backend/.env.docker
    volumes:
      - ./backend:/var/www/html
      - ./wireguard-client/wg0.conf:/etc/wireguard/wg0.conf:ro
    cap_add:
      - NET_ADMIN
    devices:
      - /dev/net/tun
    depends_on:
      - backend
    working_dir: /var/www/html
    entrypoint: >
      sh -c "wg-quick up wg0 && while true"

  estado-contable:
    image: lms-backend:latest
    container_name: estado-contable
    restart: unless-stopped
    env_file:
      - ./backend/.env.docker
    volumes:
      - ./backend:/var/www/html
      - ./wireguard-client/wg0.conf:/etc/wireguard/wg0.conf:ro
    cap_add:
      - NET_ADMIN
    devices:
      - /dev/net/tun
    depends_on:
      - backend
    working_dir: /var/www/html
    entrypoint: >
      sh -c "wg-quick up wg0 && while true; do
        php artisan update:estado-contable;
        sleep 21600;  # cada 6h
      done"

volumes:
  db_data:

docker-cron:
  image: alpine:3.18
  container_name: docker-cron
  # montamos el socket para que pueda hablar con el daemon
  volumes:
    - /var/run/docker.sock:/var/run/docker.sock:ro
  entrypoint: >
    sh -c "\
      echo '0 2 * * * docker builder prune --all --filter \"until=72h\" -f && \
                    docker image prune -af && \
                    docker volume prune -f' > /etc/crontabs/root && \
      crond -f -l 8"

# services:

#   backend:
#     build:
#       context: ./backend
#       dockerfile: Dockerfile
#     image: lms-backend:latest
#     container_name: backend
#     env_file:
#       - ./backend/.env.docker
#     ports:
#       - "8000:80"
#     volumes:
#       # - ./backend:/var/www/html
#       - ./wireguard-client/wg0.conf:/etc/wireguard/wg0.conf:ro
#     cap_add:
#       - NET_ADMIN
#     devices:
#       - /dev/net/tun
#     depends_on:
#       db:
#         condition: service_healthy
#     # NO network_mode aquí, usamos la red default de Docker

#   frontend:
#     build:
#       context: ./frontend
#       dockerfile: Dockerfile
#     container_name: frontend
#     ports:
#       - "3000:3000"
#     environment:
#       - NEXT_PUBLIC_API_URL=http://backend/api
#     volumes:
#       - /app/node_modules
#       - ./frontend:/app
#     depends_on:
#       - backend
#     # command: ["npm", "run", "dev"]    # descomentar si el Dockerfile no arranca el servidor
#     command: ["npx","next","dev","-H","0.0.0.0"]  # usa npx para invocar el CLI que está en node_modules

#   queue-worker:
#     image: lms-backend:latest
#     # container_name: lms-queue-worker
#     restart: unless-stopped
#     env_file:
#       - ./backend/.env.docker
#     volumes:
#       - ./backend:/var/www/html
#       - ./wireguard-client/wg0.conf:/etc/wireguard/wg0.conf:ro
#     cap_add:
#       - NET_ADMIN
#     devices:
#       - /dev/net/tun
#     depends_on:
#       - backend
#     working_dir: /var/www/html
#     entrypoint: >
#       sh -c "wg-quick up wg0 && php artisan queue:work --sleep=3 --tries=3"
#     # deploy:
#     #   replicas: 5

#   scheduler:
#     image: lms-backend:latest
#     container_name: lms-scheduler
#     restart: unless-stopped
#     env_file:
#       - ./backend/.env.docker
#     volumes:
#       - ./backend:/var/www/html
#       - ./wireguard-client/wg0.conf:/etc/wireguard/wg0.conf:ro
#     cap_add:
#       - NET_ADMIN
#     devices:
#       - /dev/net/tun
#     depends_on:
#       - backend
#     working_dir: /var/www/html
#     entrypoint: >
#       sh -c "wg-quick up wg0 && while true; do
#         php artisan schedule:run --no-interaction --verbose;
#         sleep 3;
#       done"

#   estado-contable:
#     image: lms-backend:latest
#     container_name: estado-contable
#     restart: unless-stopped
#     env_file:
#       - ./backend/.env.docker
#     volumes:
#       - ./backend:/var/www/html
#       - ./wireguard-client/wg0.conf:/etc/wireguard/wg0.conf:ro
#     cap_add:
#       - NET_ADMIN
#     devices:
#       - /dev/net/tun
#     depends_on:
#       - backend
#     working_dir: /var/www/html
#     entrypoint: >
#       sh -c "wg-quick up wg0 && while true; do
#         php artisan update:estado-contable;
#         sleep 21600;  # cada 6h
#       done"

#   db:
#     image: mysql:8.0
#     restart: unless-stopped
#     environment:
#       MYSQL_ROOT_PASSWORD: root123!
#       MYSQL_DATABASE: lms_backend
#       MYSQL_USER: restrella
#       MYSQL_PASSWORD: "LogeX-?2028*"
#     volumes:
#       - db_data:/var/lib/mysql
#     healthcheck:
#       test: [ "CMD", "mysqladmin", "ping", "-h", "localhost", "-uroot", "-proot123!" ]
#       interval: 10s
#       timeout: 5s
#       retries: 5
#     networks:
#       default:
#         aliases:
#           - db

# volumes:
#   db_data:
#   frontend_node_modules:


# # Para configuracion de permisos de Docker para que funcinoe:

# # docker exec -it --user root lms-backend bash
# # cd /var/www/html

# # Asegúrate de que www-data (usuario de Apache/PHP) sea dueño:
# # chown -R www-data:www-data storage

# # Dale permisos de escritura al grupo:
# # chmod -R 775 storage


# # Para la parte de deploy (asi mismo en produccion)
# # 1) Entrar al directorio
# # cd /path/to/lms-restored

# # 2) Actualizar el código
# # git pull origin main

# # 3) Bajar y limpiar viejos containers
# # docker compose down --remove-orphans

# # 4) Traer la nueva imagen (si la construyes en CI y la subes a un registry)
# # docker compose pull

# # 5) Levantar todo con el código nuevo
# # docker compose up -d